// src/router/reg-exp-router/prepared-router.ts
import { METHOD_NAME_ALL } from "../../router.js";
import { match, buildAllMatchersKey, emptyParam } from "./matcher.js";
import { RegExpRouter } from "./router.js";
var PreparedRegExpRouter = class {
  name = "PreparedRegExpRouter";
  #matchers;
  #relocateMap;
  constructor(matchers, relocateMap) {
    this.#matchers = matchers;
    this.#relocateMap = relocateMap;
  }
  add(method, path, handler) {
    const all = this.#matchers[METHOD_NAME_ALL];
    this.#matchers[method] ||= [
      all[0],
      all[1].map((list) => Array.isArray(list) ? list.slice() : 0),
      Object.keys(all[2]).reduce((obj, key) => {
        obj[key] = [all[2][key][0].slice(), emptyParam];
        return obj;
      }, {})
    ];
    if (path === "/*" || path === "*") {
      const defaultHandlerData = [handler, {}];
      (method === METHOD_NAME_ALL ? Object.keys(this.#matchers) : [method]).forEach((m) => {
        const matcher = this.#matchers[m];
        matcher[1].forEach((list) => list && list.push(defaultHandlerData));
        Object.values(matcher[2]).forEach(
          (list) => list[0].push(defaultHandlerData)
        );
      });
      return;
    }
    const data = this.#relocateMap[path];
    if (!data) {
      throw new Error(`Path ${path} is not registered`);
    }
    for (const [indexes, map] of data) {
      ;
      (method === METHOD_NAME_ALL ? Object.keys(this.#matchers) : [method]).forEach((m) => {
        const matcher = this.#matchers[m];
        if (!map) {
          matcher[2][path][0].push([handler, {}]);
        } else {
          indexes.forEach((index) => {
            if (typeof index === "number") {
              matcher[1][index].push([handler, map]);
            } else {
              ;
              matcher[2][index || path][0].push([handler, map]);
            }
          });
        }
      });
    }
  }
  [buildAllMatchersKey]() {
    return this.#matchers;
  }
  match = match;
};
var buildInitParams = ({ paths }) => {
  const router = new RegExpRouter();
  for (const path of paths) {
    router.add(METHOD_NAME_ALL, path, path);
  }
  const matchers = router[buildAllMatchersKey]();
  const all = matchers[METHOD_NAME_ALL];
  const relocateMap = {};
  for (const path of paths) {
    all[1].forEach((list, i) => {
      list.forEach(([p, map]) => {
        if (p === path) {
          if (relocateMap[path]) {
            relocateMap[path][0][1] = {
              ...relocateMap[path][0][1],
              ...map
            };
          } else {
            relocateMap[path] = [[[], map]];
          }
          if (relocateMap[path][0][0].findIndex((j) => j === i) === -1) {
            relocateMap[path][0][0].push(i);
          }
        }
      });
    });
    for (const path2 in all[2]) {
      all[2][path2][0].forEach(([p]) => {
        if (p === path) {
          relocateMap[path] ||= [[[], void 0]];
          const value = path2 === path ? "" : path2;
          if (relocateMap[path][0][0].findIndex((v) => v === value) === -1) {
            relocateMap[path][0][0].push(value);
          }
        }
      });
    }
  }
  for (let i = 0, len = all[1].length; i < len; i++) {
    all[1][i] = all[1][i] ? [] : 0;
  }
  for (const path in all[2]) {
    all[2][path][0] = [];
  }
  return [matchers, relocateMap];
};
var serializeInitParams = ([matchers, relocateMap]) => {
  for (const method in matchers) {
    const matcher = matchers[method];
    matcher[0].toJSON = function() {
      return `@${this.toString()}@`;
    };
  }
  const matchersStr = JSON.stringify(matchers).replace(
    /"@(.+?)@"/g,
    (_, str) => str.replace(/\\\\/g, "\\")
  );
  const relocateMapStr = JSON.stringify(relocateMap);
  return `[${matchersStr},${relocateMapStr}]`;
};
export {
  PreparedRegExpRouter,
  buildInitParams,
  serializeInitParams
};
