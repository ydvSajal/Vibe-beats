"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var prepared_router_exports = {};
__export(prepared_router_exports, {
  PreparedRegExpRouter: () => PreparedRegExpRouter,
  buildInitParams: () => buildInitParams,
  serializeInitParams: () => serializeInitParams
});
module.exports = __toCommonJS(prepared_router_exports);
var import_router = require("../../router");
var import_matcher = require("./matcher");
var import_router2 = require("./router");
class PreparedRegExpRouter {
  name = "PreparedRegExpRouter";
  #matchers;
  #relocateMap;
  constructor(matchers, relocateMap) {
    this.#matchers = matchers;
    this.#relocateMap = relocateMap;
  }
  add(method, path, handler) {
    const all = this.#matchers[import_router.METHOD_NAME_ALL];
    this.#matchers[method] ||= [
      all[0],
      all[1].map((list) => Array.isArray(list) ? list.slice() : 0),
      Object.keys(all[2]).reduce((obj, key) => {
        obj[key] = [all[2][key][0].slice(), import_matcher.emptyParam];
        return obj;
      }, {})
    ];
    if (path === "/*" || path === "*") {
      const defaultHandlerData = [handler, {}];
      (method === import_router.METHOD_NAME_ALL ? Object.keys(this.#matchers) : [method]).forEach((m) => {
        const matcher = this.#matchers[m];
        matcher[1].forEach((list) => list && list.push(defaultHandlerData));
        Object.values(matcher[2]).forEach(
          (list) => list[0].push(defaultHandlerData)
        );
      });
      return;
    }
    const data = this.#relocateMap[path];
    if (!data) {
      throw new Error(`Path ${path} is not registered`);
    }
    for (const [indexes, map] of data) {
      ;
      (method === import_router.METHOD_NAME_ALL ? Object.keys(this.#matchers) : [method]).forEach((m) => {
        const matcher = this.#matchers[m];
        if (!map) {
          matcher[2][path][0].push([handler, {}]);
        } else {
          indexes.forEach((index) => {
            if (typeof index === "number") {
              matcher[1][index].push([handler, map]);
            } else {
              ;
              matcher[2][index || path][0].push([handler, map]);
            }
          });
        }
      });
    }
  }
  [import_matcher.buildAllMatchersKey]() {
    return this.#matchers;
  }
  match = import_matcher.match;
}
const buildInitParams = ({ paths }) => {
  const router = new import_router2.RegExpRouter();
  for (const path of paths) {
    router.add(import_router.METHOD_NAME_ALL, path, path);
  }
  const matchers = router[import_matcher.buildAllMatchersKey]();
  const all = matchers[import_router.METHOD_NAME_ALL];
  const relocateMap = {};
  for (const path of paths) {
    all[1].forEach((list, i) => {
      list.forEach(([p, map]) => {
        if (p === path) {
          if (relocateMap[path]) {
            relocateMap[path][0][1] = {
              ...relocateMap[path][0][1],
              ...map
            };
          } else {
            relocateMap[path] = [[[], map]];
          }
          if (relocateMap[path][0][0].findIndex((j) => j === i) === -1) {
            relocateMap[path][0][0].push(i);
          }
        }
      });
    });
    for (const path2 in all[2]) {
      all[2][path2][0].forEach(([p]) => {
        if (p === path) {
          relocateMap[path] ||= [[[], void 0]];
          const value = path2 === path ? "" : path2;
          if (relocateMap[path][0][0].findIndex((v) => v === value) === -1) {
            relocateMap[path][0][0].push(value);
          }
        }
      });
    }
  }
  for (let i = 0, len = all[1].length; i < len; i++) {
    all[1][i] = all[1][i] ? [] : 0;
  }
  for (const path in all[2]) {
    all[2][path][0] = [];
  }
  return [matchers, relocateMap];
};
const serializeInitParams = ([matchers, relocateMap]) => {
  for (const method in matchers) {
    const matcher = matchers[method];
    matcher[0].toJSON = function() {
      return `@${this.toString()}@`;
    };
  }
  const matchersStr = JSON.stringify(matchers).replace(
    /"@(.+?)@"/g,
    (_, str) => str.replace(/\\\\/g, "\\")
  );
  const relocateMapStr = JSON.stringify(relocateMap);
  return `[${matchersStr},${relocateMapStr}]`;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  PreparedRegExpRouter,
  buildInitParams,
  serializeInitParams
});
